---
layout: post
title: Gap buffer и редактирование текста.
categories: personal
tags: 
  - coding
  - emacs
comments: true
mathjax: null
featured: true
published: true
---

Здесь я расскажу об одной структуре данных, или точнее идиоме, которая мне
кажется интересной. Наверняка многие задумывались как эффективно реализованы
вставка и удаление в текстовых редакторах. При этом используется специального
вида динамический массив. Эта техника была известна давно, ещё, как минимум,
в самом начале 70-х годов: <a
href="http://history.dcs.ed.ac.uk/archive/apps/ecce/hmd/e915.imp.html">http://history.dcs.ed.ac.uk/archive/apps/ecce/hmd/e915.imp.html</a>

<!--excerpt-->

# Emacs gap buffer

Думаю лучше начать с примера. В Emacs'е, согласно документации, буферы(так
называется его "окна") реализованы с использованием невидимого зазора(gap),
который позволяет выполнять вставку и удаление быстрее. Конечно, это
означает, что этот зазор должен быть перемещен в место вставки или удаления.
В Emacs зазор перемещается только когда(точнее перед) тем как вы пытаетесь
выполнить вставку или удаление. Вот почему вы получаете задержку на первой
команде редактирования в большом буфере, если начинаете редактирование на
другой части буфера, далекой от предыдущей, при этом задержка может быть
весьма заметной. Этот механизм работает для всех буферов Emacs и прозрачно
для его Lisp кода.

Рассмотрим пример:

1. Начальное состояние. Длина gap buffer = 20.
2. Вставляем слово cow. Gap buffer уменьшается.
3. Вставляем ещё текста. Gap buffer заполняется и создается новый.

{% highlight text %}
1) There is no [                    ]level.
2) There is no cow[                 ]level.
3) There is no cow no dog no cat no nothing[                    ]level.
{% endhighlight %}

Чтобы понять как это реализовано, говоря в терминах C++ вы должы представлять
себе не std::vector, а что-то вроде std::array_list, то есть пару указателей,
на начало и конец, а не буфер, который что-то активно выделяет и освобождает
при переполнении(это свело бы на нет всё преимущество этой техники).

# Альтернативы gap buffer

Альтернативой gap buffer может служить line-based архитектура, которая
используется в vim. Она позволяет быстро выполнять операции, при которых
получается много новых строк или которые базируются на строках, но так же
ведет и к проблемам, например в части редактирования чего-то вроде
xml-файлов, где новых строк может и не быть или к плохой производительности
подсветки синтаксиса.

В маленькой статье <a
href="https://www.cs.unm.edu/~crowley/papers/sds.pdf">Data Structures for
Text Sequences</a> описаны peice buffer'ы, которые используются например в <a
href="https://github.com/martanne/vis">vis</a>, это vim-подобный текстовый
редактор, который поддерживает большую часть вимовских операций над текстом.
Его достоинство заключается в том, что он может работать быстро там, где vim
не может(например бинарные файлы, файлы в одну строку и тд и тп), посмотреть
на то как быстро с текстом работает это чудо можно, например, вот здесь: <a
href="https://asciinema.org/a/41361">https://asciinema.org/a/41361</a>. Также
peice buffer позволяет выполнять операции на памяти, отображенной с помощью
mmap, что важно для больших файлов. 

Также существуют веревки(rope), это
структура данных для представления очень длинных строк. Может быть я расскажу
о ней позднее, она не совсем про редактирование.

<a href="https://wiki.haskell.org/Zipper">Zypper</a> представляет собой
обобщение этой идеи на другие структуры данных, например бинарные деревья.
Правда по большей части это применимо только к функциональным языкам типа
того же haskell. Если кому интересно могу рассказать и об этом, пишите
к комментах.

