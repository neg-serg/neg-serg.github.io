---
layout: post
title: vim as IDE
description: "Its ON, baby"
headline: "Let's Fire up the Engines"
categories: personal
tags: 
  - blogging
  - jekyll
imagefeature: "website-speed.jpg"
imagecredit: spreadeffect.com
imagecreditlink: "http://www.spreadeffect.com/blog/improve-website-speed/"
comments: false
mathjax: null
featured: true
published: true
---

>&quot;The beginning is the most important part of the work.&quot;
><small><cite title="Plato">Plato</cite></small>

Vim как IDE
===================

Довольно часто сталкиваюсь с мнением, что всякого рода "простые" редакторы для разработки не подходят и делать это можно почему-то только в каком-нибудь eclipse или чем-то вроде того и ничего что оно тянет за собой jvm, долго грузится, а на нетбуках так и вовсе без хороших танцев с бубном с этим работать невозможно. Я покажу как можно настроить вим для удобной работы с кодом, что будет интересно его энтузиастам или тем кто использует его из-за политики компании(да, такое внезапно бывает).

Сразу скажу что я использую чистый vim с эмулятором терминала st(потому что у urxvt у меня криво работает font fallback, а обычные эмуляторы терминала потребляют много ресурсов и на фоне этих медленно работают), а не gvim, потому что это дает большие преимущества в плане интеграции с tmux и многое другое.

Кто вообще не знает как им пользоваться может обратиться сначала к vimtutor, а потом к *:help*. В том что касается vim script довольно много *dark corners*, с ними, если есть желание, лучше разбираться на реальных плагинах, которые лежат на гитхабе. В целом это не самый приятный язык, вот в NeoVim(https://neovim.io/) от него пытаются отойти в сторону lua, а для legacy кода на VimL сделать конвертер. Как-нибудь позже про него напишу, он даже почти юзабельный, лично для меня не хватает, пожалуй, полной поддержки биндингов python 2/3(например powerline использовать пока не выйдет) и нормальной поддержки биндингов ruby. Остается надеяться, что это будет решено в будущем. За прогрессом в области поддержки моей любимой powerline можно поглядеть вот здесь:
https://github.com/powerline/powerline/pull/1507

~/.vimrc
-------------

Мой конфиг лежит на https://github.com/neg-serg/dotfiles

Вместо единого файла настроек в ~/.vimrc у меня их целый огород, в основном конфиге лишь некоторый стаффчик вроде профилировки и прочего. Итак, что там есть:

{% highlight vim %}
scriptencoding utf-8
set noexrc
set secure
set shell=/bin/sh

" Note: Skip initialization for vim-tiny or vim-small.
if !1 | finish | endif
{% endhighlight %}

Это "стандартные" и полезные установки чтобы все плагины корректно загрузились/установились. И ещё "guard" для "обрезанного" вима чтобы зря не писал много warning'ов и error'ов. К тому же в 21-ом веке нет большого резона использовать что-то кроме utf8.

Полезной функцией является вот эта, которую я нашел, кажется, на slashdot'е:

{% highlight vim %}
if 1
    fun! ProfileStart()
        let profile_file = '/tmp/vim.'.getpid().'.profile.txt'
        echom "Profiling into" profile_file
        exec 'profile start '.profile_file
        profile! file **
        profile  func *
    endfun
    if get(g:, 'profile')
        call ProfileStart()
    endif
endif
{% endhighlight %}

Здесь написано что если вим всё поддерживает, то добавить функцию для профилировки. Результаты будут записаны в /tmp/vim*profile.txt, их анализ труда не представляет. Это можно использовать когда вим тормозит непонятно почему. С большой долей вероятности первые строчки списков покажут "вредителя".

Ещё одна забавная штука:
{% highlight vim %}
if has('vim_starting') && has('reltime')
    let g:startuptime = reltime()
    augroup vimrc-startuptime
        autocmd! VimEnter * let g:startuptime = reltime(g:startuptime)
                    \ | redraw
                    \ | echomsg 'startuptime: ' . reltimestr(g:startuptime)
    augroup END
endif
{% endhighlight %}

Показывает в сообщений время, которое ушло на запуск. *echom* добавляет инфу не только на вывод, но и в :messages, так что это всегда можно посмотреть если пропустили. Значения типа 30s дают повод задуматься :)

{% highlight vim %}
if has('vim_starting')
    filetype off
    set nocompatible  "be improved
    set runtimepath+=~/.vim/bundle/neobundle.vim/
    if !has("nvim")
        set runtimepath+=/usr/lib/python2.7/site-packages/powerline/bindings/vim
    endif
	set runtimepath+=~/.fzf
endif
{% endhighlight %}

Это инициализация для NeoBundle, а также для powerline(красивая статусная строка, о ней, пожалуй, расскажу отдельно) и fzf, очень удобного, быстрого независимого от vim fuzzyfinder'а для быстрой навигации по файлам вроде того что есть в продуктах jetbrains. Чтобы он(fzf) работал ещё понадобится tmux, терминальный мультиплексор.

Поддержа python2 в neovim:

{% highlight vim %}
if has('nvim')
    let g:python_interpreter='python2'
        let &rtp = expand('~/.vim/') . ','
    \        . expand('~/.vim/after/') . ',' . &rtp
    runtime! plugin/python_setup.vim
    let $NVIM_TUI_ENABLE_TRUE_COLOR=1
endif
{% endhighlight %}

И инициализация NeoBundle:

{% highlight vim %}
let s:bundle_dir = expand('$HOME/.vim/bundle')
let s:neobundle_dir = s:bundle_dir . '/neobundle.vim'
let s:neobundle_repo = 'https://github.com/Shougo/neobundle.vim'
let g:neobundle#cache_file = expand('$HOME/.vim/neobundlecache')
let &runtimepath.=','.s:neobundle_dir
try
	call neobundle#begin(s:bundle_dir)
catch /E117/ " neobundle not installed
	execute "!mkdir -p " .  s:neobundle_dir
	execute "!" . "git clone " s:neobundle_repo . " " . s:neobundle_dir
	call neobundle#begin(s:bundle_dir)
	NeoBundleInstall
	call neobundle#end()
	quit
endtry

if neobundle#load_cache()
    source ~/.vim/00-bundlelist.vim
    NeoBundleSaveCache
endif
call neobundle#end()
if (&t_Co > 2 || has("gui_running"))
    syntax on
endif
filetype plugin indent on

NeoBundleCheck
{% endhighlight %}

-------------

Плагины
-------------

Начну наверно с описания плагинов, потому что без них получить хороший автокомплит и тому подобные плюшки в виме не получится.

В качестве менеджера для плагинов я использую NeoBundle вместо Vundle, в основном потому что он поддерживает кэширование, "ленивую" загрузку плагинов по тригеррам, комментарии после NeoBundle <...> и вообще есть не просит.

Список плагинов у меня такой: https://raw.githubusercontent.com/neg-serg/dotfiles/master/.vim/00-bundlelist.vim

Выглядит внушительно, но на самом деле всё не так страшно как кажется. Только некоторые из них имеют решающее значение, вроде YouCompleteMe, остальные это скорее приятное дополнение вроде файлов для подсветки синтаксиса или чего-то такого от чего я использую примерно одну команду(вроде vim-rename2)

#### YouCompleteMe

Чудо, произведенное на свет сотрудником google Valloric'ом. Дает быстрый автокомплит прямо во время печати с fuzzy-finding'ом. Выглядит это примерно вот так:

![YouCompleteMe GIF demo](http://i.imgur.com/0OP4ood.gif)

Из языков  сишной группы поддерживается C/C++/Objective-C/Objective-C++ через Clang. Лично я использовал только C и C++. Всё это требует специального конфига на питоне, в котором будут команды для Clang-компилера. Я считаю что есть два неплохих примера, с которыми всё стабильно работает достаточно, основной у меня лежит по адресу ~/.vim/.ycm_extra_conf.py. Самая понятная из модификаций часть у него это flags. Если в списке flags неправильные пути для c++-шных библиотек, то clang их просто не увидит, но в целом это легко исправить руками, достаточно посмотреть с помощью, например, *ls /usr/include/c++*. Кроме того после установки нужно не забыть скомпилировать его с помощью, например

{% highlight sh %}
./install.sh --clang-completer --system-libclang --system-boost
{% endhighlight %}

Поддержку omnisharp можно добавить по вкусу. Флаги с префиксом *--system* говорят о том чтобы он использовал те версии библиотек, которые уже есть в системе, вместо выкачивания своих. Для Arch linux это работает замечательно, в других дистрибутивах это может быть не так(особенно, наверное, вроде debian или mint)

Честно говоря с нахождением нормального работающего конфига под clang у меня в своё время были проблемы, пришлось запиливать его самому на базе образца что был у автора.

Итак, вот фрагмент "классического" примера .ycm_extra_conf.py:

{% highlight python %}
import os
import ycm_core

# These are the compilation flags that will be used in case there's no
# compilation database set (by default, one is not set).
# CHANGE THIS LIST OF FLAGS. YES, THIS IS THE DROID YOU HAVE BEEN LOOKING FOR.
flags = [
'-Wall',
'-Wextra',
'-Werror',
'-Wno-long-long',
'-Wno-variadic-macros',
'-fexceptions',
'-DNDEBUG',
# You 100% do NOT need -DUSE_CLANG_COMPLETER in your flags; only the YCM
# source code needs it.
'-DUSE_CLANG_COMPLETER',
# THIS IS IMPORTANT! Without a "-std=<something>" flag, clang won't know which
# language to use when compiling headers. So it will guess. Badly. So C++
# headers will be compiled as C headers. You don't want that so ALWAYS specify
# a "-std=<something>".
# For a C project, you would set this to something like 'c99' instead of
# 'c++11'.
'-std=c++11',
# ...and the same thing goes for the magic -x option which specifies the
# language that the files to be compiled are written in. This is mostly
# relevant for c++ headers.
# For a C project, you would set this to 'c' instead of 'c++'.
'-x',
'c++',
'-isystem',
'../BoostParts',
'-isystem',
# This path will only work on OS X, but extra paths that don't exist are not
# harmful
'/System/Library/Frameworks/Python.framework/Headers',
'-isystem',
'../llvm/include',
'-isystem',
'../llvm/tools/clang/include',
'-I',
'.',
'-I',
'./include',
'../include',
'-I',
'./ClangCompleter',
'-isystem',
'./tests/gmock/gtest',
'-isystem',
'./tests/gmock/gtest/include',
'-isystem',
'./tests/gmock',
'-isystem',
'./tests/gmock/include',
'-isystem',
'/usr/include',
'-isystem',
'/usr/local/include',
'-isystem',
'-I',
'/usr/include/c++/4.9.1',
'-I',
'/usr/include/c++/5.1.0',
'/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/c++/v1',
'-isystem',
'/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include',
]
{% endhighlight %}

В итоге всё должно полностью работать.

#### bear

Также есть такая интереская штука как bear. https://github.com/rizsotto/Bear
Она нужна для создания JSON compilation database Clang'а. В результате мы получаем что-то вроде "менеджера проекта". Работа с ним выглядит примерно так: берем проект на си или c++, идем в директорию с ним, далее если в качестве команды сборки используется make, то просто пишем

{% highlight sh %}
bear make
{% endhighlight %}

В случае cmake можно использовать

{% highlight sh %}
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
{% endhighlight %}

В результате мы получаем автокомплит для этого проекта с учетом всех его опций компиляции, путей и прочего. Как недостаток придется подождать пока это приложение скомпилируется, зато дальше всё работает очень быстро.

Для того чтобы YouCompleteMe всё корректно подхватил нужно положить этот файл в директорию с проектом(чтобы он переопределил тот который в ~/.vim):

{% highlight python %}
import sys
from os import listdir, getcwd, environ, devnull
from os.path import abspath, normpath, split, join, expanduser, isfile, isdir, isabs, splitdrive, splitext
import subprocess as sp
import ycm_core

cc = 'g++'
dirname = lambda x: split(x)[0]
basename = lambda x: split(x)[1]
database = None

def head_cat(p):
  try:
    with open(p, 'r') as f:
      return f.readline()
  except IOError:
    return ''

def default_cast(ttype, value, deflt=None):
  try:
    return ttype(value)
  except ValueError:
    if deflt is None:
      return ttype()
    return deflt

def is_root_dir(d):
  if isdir(d) and (basename(abspath(d)) == 'trunk' or basename(abspath(join(d, '..'))) in ('tags', 'branches')):
    return True
  for f in listdir(d):
    p = join(d, f)
    if isfile(p) and f in ('.ycm_extra_conf.py', 'Jamroot', 'Jamroot.jam', 'project-root.jam'):
      return True
    elif isdir(p):
      if f in ('.git', '.hg', '.bzr'):
        return True
      # .svn/format >= 12 means svn client 1.7 with centralized meta-data.
      elif f == '.svn' and default_cast(long, head_cat(join(p, 'format'))) >= 12:
        return True
  return False

def get_root_dir(cwd=None):
  if cwd is None: cwd = getcwd()
  while (normpath(splitdrive(cwd)[1]) not in ('/', '\\', '')):
    if is_root_dir(cwd):
      return cwd
    cwd = join(cwd, '..')
  return None

def abslistdir(p):
  absp = abspath(p)
  return (join(absp, x) for x in listdir(absp))

here = dirname(abspath(__file__))
root = get_root_dir(here)
if not root:
  root = here[:]
if isfile(join(root, 'compile_commands.json')):
  database = ycm_core.CompilationDatabase(root)
  if not database.DatabaseSuccessfullyLoaded():
    database = None

path_flags = ['-isystem', '-I', '-iquote', '--sysroot=']
def StripPathFlags(f):
  for p in path_flags:
    if f.startswith(p):
      if len(f) > len(p): return f[len(p):]
      else: return ''
  return f

def SplitPathFlags(fs):
  new_fs = []
  for f in fs:
    new_f = [f]
    for p in path_flags:
      lenp = len(p)
      if f.startswith(p) and len(f) > lenp:
        new_f = [f[:lenp], f[lenp:]]
        continue
    new_fs.extend(new_f)
  return new_fs

def DefaultFlags():
  paths = (absp for absp in abslistdir(root) if isdir(absp) and not basename(absp).startswith('.'))
  fs = ['-x', 'c++', '-std=c++11', '-I', root]
  for path in paths:
    includes = [p for p in abslistdir(path) if isdir(p) and basename(p) in ('include', 'inc')]
    if not includes:
      fs.extend(['-I', path])
    else:
      for inc in includes:
        fs.extend(['-I', inc])
  return fs

def MakeRelativePathsInFlagsAbsolute(fs, working_directory):
  if not working_directory:
    return list(fs)
  new_fs = []
  make_next_absolute = False
  for f in fs:
    new_f = f
    if make_next_absolute:
      make_next_absolute = False
      if not f.startswith('/'):
        new_f = join(working_directory, f)
    for p in path_flags:
      if f == p:
        make_next_absolute = True
        break
      if f.startswith(p):
        path = f[len(p):]
        new_f = p + join(working_directory, path)
        break
    if new_f:
      new_fs.append(new_f)
  return new_fs

def StripNonFlags(fs):
  """Please rewrite this: check for desired flags instead of removing unwanted ones."""
  if not fs:
    return []
  non_flag_opts = ('-c', '-o')
  non_flag_args = ('-W', '-O', '-f', '-pipe', '-g', '-m')
  new_fs = [fs[0]]
  is_arg = False
  skip_next = False
  for f in fs[1:]:
    if skip_next:
      skip_next = False
    elif not is_arg and f in non_flag_opts:
      skip_next = True
    elif not any((f.startswith(a) for a in non_flag_args)):
      if is_arg:
        is_arg = False
        new_fs.append(f)
      elif f.startswith('-') and len(f) > 1:
        is_arg = True
        new_fs.append(f)
      elif not f.startswith('-'):
        pass
  return new_fs

def AddSourceStdFlags(fs):
  if not fs:
    return []
  fs = fs[:]
  explicit_std = False
  std = None
  for f in fs:
    if f.startswith('-std='):
      explicit_std = True
      std = f
  explicit_src = False
  src = None
  is_arg = False
  is_src = False
  for f in fs:
    if is_src:
      explicit_src = True
      src = f
      break
    elif not is_arg and f == '-x':
      is_src = True
    elif f.startswith('-') and len(f) > 1:
      is_arg = True
    elif is_arg:
      is_arg = False
  cc = fs[0]
  if not src:
    if cc.endswith('++') or cc.startswith('cl'):
      src = 'c++'
    elif cc.startswith('cc') or cc.endswith('cc') or cc.startswith('clang'):
      src = 'c'
  if not src and std:
    if std.find('++') >= 0:
      src = 'c++'
    else:
      src = 'c'
  elif src and not std:
    std = '-std=' + src + '11'
  elif not src and not std:
    src = 'c++'
    std = '-std=c++11'
  if not explicit_std and std:
    fs.insert(1, std)
  if not explicit_src and src:
    fs.insert(1, src)
    fs.insert(1, '-x')
  return fs

def HeaderToSources(filename):
  """Convert a header filename into a sequence of potential source filenames."""
  head = splitext(filename)[0]
  if filename.endswith('.h'):
    return (head + e for e in ('.cc', '.cpp', '.c'))
  elif filename.endswith('.hh'):
    return (head + '.cc',)
  elif filename.endswith('.hpp'):
    return (head + '.cpp',)
  elif filename.endswith('.hxx'):
    return (head + '.cxx',)
  else:
    return (filename,)

def FlagsForFile(filename):
  if not database:
    flags = DefaultFlags()
  else:
    for f in HeaderToSources(filename):
      # GetCompilationInfoForFile returns a "list-like" StringVec object.
      compilation_info = database.GetCompilationInfoForFile(abspath(f))
      flags = AddSourceStdFlags(StripNonFlags(MakeRelativePathsInFlagsAbsolute(
        compilation_info.compiler_flags_,
        compilation_info.compiler_working_dir_ )))[1:]
      if flags:
        break
  return {'flags': SplitPathFlags(flags), 'do_cache': True}
{% endhighlight %}


Также есть поддержка автодополнения для python с помощью jedi(нужно ставить только jedi, без плагина jedi-vim), c# с помощью omnisharp(нужно следить чтобы были правильно настроены файлы solution и project),  а также go и typescript(эти я не пробовал, так что как работает не знаю). Также будет поддерживаться всё где есть omni-complete для любого языка. Под поддержкой имеется в виду fuzzy-finding поиск, инкрементальное автодополнение в этом случае было бы слишком медленным.

Настройки для YouCompleteMe можно посмотреть в файле *~/.vim/03-plugins-config.vim*

На мой взгляд интересная особенность это возможность включения и выключения ycm, например это может понадобиться если автокомплит по каким-то причинам сильно тормозит:

{% highlight vim %}
nnoremap <silent> <F3> :call youcompleteme#DisableCursorMovedAutocommands()<CR>
nnoremap <silent> <F4> :call youcompleteme#EnableCursorMovedAutocommands()<CR>
{% endhighlight %}

Также строки вида
{% highlight vim %}
if neobundle#tap('YouCompleteMe')
{% endhighlight %}

Позволяют загружать конфигуацию только когда плагин уже присутствует, что по идее должно уменьшать интерференциюю между ними и ускорять загрузку.

С помощью этого уже можно неплохо писать код и выполнять навигацию по нему с помощью команд :YcmCompleter, теги для этого не требуются. Но так бывает не всегда так что рассмотрим создание тегов.

### Теги gtags > cscope > ctags и навигация по коду

Обычно все используют в качестве тегов для vim Exuberant Ctags(http://ctags.sourceforge.net) или cscope(http://cscope.sourceforge.net), для обоих из которых у вима достаточно неплохая поддержка. Cscope предоставляет более удобный интерфейс и помимо простого перехода по тегам мы имеем список возможных переходов(например это возникает при overloading'е функций), возможность обратного поиска, то есть где вызывается данная функция, а не только переход к телу или прототипу. В общем хорошая штука, которая поинтереснее чем ctags, к тому же есть приятная cli утилита для работы с cscope db. А ctags поддерживаются даже в vi. Но как по мне это не самое лучшее решение, за сравнением можно глянуть вот сюда: https://github.com/OpenGrok/OpenGrok/wiki/Comparison-with-Similar-Tools

В целом могу сказать что gtags быстрее работают, занимают меньше места и имеют больше фич. В общем мастхэв. Кроме того есть интеграция с cscope системой для тегов. Дело в том что к сожалению поддержка cscope в vim'е прибита гвоздями, так что сделать такую же классную навигацию как для cscope не так-то просто(по крайней мере я такой интеграции не видел), но к счастью есть gtags-cscope, который ведет себя в точности как cscope и вим его нормально воспринимает через те же самые команды, не надо переучиваться.

В качестве альтернативы было бы интересно посмотреть на https://github.com/Andersbakken/rtags. Кое-какая поддержка в vim'е есть, но она пока оставляет желать лучшего. К тому же так же требует поддержки clang, что, пока, возможно не для любых проектов(совместимость с gcc у clang пока неполная)

Прежде всего рекомендую небольшую настройку:
{% highlight vim %}
if has("cscope")
    if executable("gtags")
        set csprg=/usr/bin/gtags-cscope
    else
        set csprg=/usr/bin/cscope
    endif
    set csto=0
    set cscopetag
    " set cscopequickfix=s-,c-,d-,i-,t-,e-

    let GtagsCscope_Auto_Map        = 1
    let GtagsCscope_Use_Old_Key_Map = 0
    let GtagsCscope_Ignore_Case     = 1
    let GtagsCscope_Absolute_Path   = 1
    let GtagsCscope_Keep_Alive      = 1
    let GtagsCscope_Auto_Load       = 0
endif
{% endhighlight %}

Вот плагины, которые относятся к gtags:

{% highlight vim %}
if executable("gtags")
    NeoBundle 'yuki777/gtags.vim.git' "Gtags v0.64
    NeoBundle 'bbchung/gasynctags.git' "autogenerate gtags to cscope db
    NeoBundle 'tranngocthachs/gtags-cscope-vim-plugin.git' "gtags-cscope navigation
endif
{% endhighlight %}

Первый это плагин, который поставляется с gnu global, более-менее свежей версии. Его достоинство в том, что поддерживает практически всё то же, что и сам gtags. gasynctags нужен для асинхронного обновления тегов, в противном случае этот процесс для большого проекта занимал бы довольно много времени. Эту операцию можно выполнять автоматически, а можно забиндить на хоткей:

{% highlight vim %}
<Space>d      :GasyncTagsEnable<CR>:GtagsCscope<CR>
{% endhighlight %}

gtags-cscope-vim-plugin делает хоткеи для gtags такими же как и для cscope, довольно удобно. В случае чего их можно легко поменять. Которые начинаются с <kbd>Ctrl+@</kbd> в моем сетапе вообще особого смысла не имеют, потому что для этого есть *drmikehenry/vim-fixkey*, он позволяет использовать биндинги gvim в vim.

В общем-то дальше всё как обычно, делаем chdir в проект, потом жмем <kbd>Space+d</kbd> и теги создаются. Кстати chdir удобно делать с помощью *dbakker/vim-projectroot*, он автоматически распознает директории с репозиториями, что удобно(позволяет сразу перейти в проект). Работаем с тегами gnu global как с cscope.

### Сниппеты и UltiSnips

Другой популярной возможностью кодерских редакторов является поддержка сниппетов. Они позволяют редактору писать код за вас. Выглядит это чудо приблизительно вот так:


![GIF Demo](https://raw.github.com/SirVer/ultisnips/master/doc/demo.gif)

Как его конфигурировать можно найти прямо на его странице https://github.com/SirVer/ultisnips
Там есть скринкасты и всё понятно.

Остальные движки для сниппетов с YouCompleteMe вроде как не совместимы. В качестве тригерра лично мне удобно использовать <kbd>[Alt]+s</kbd>:

{% highlight vim %}
if neobundle#tap('ultisnips')
    let g:UltiSnipsSnippetsDir         = $HOME . './vim/UltiSnips'
    if has("gui_macvim")
        " Ctrl conflicts with Dvorak-Qwerty Command
        let g:UltiSnipsExpandTrigger       = "<m-s>"
    else
        let g:UltiSnipsExpandTrigger       = "<m-s>"
        let g:UltiSnipsJumpForwardTrigger  = "<m-s>"
        let g:UltiSnipsJumpBackwardTrigger = "<m-f>"
        let g:UltiSnipsListSnippets        = "<c-m-s>"
    endif
endif
{% endhighlight %}

#### Динамическая проверка синтаксиса

Большая часть хороших современных IDE выдает подсказки, когда что-то написано неправильно. Получить то же самое в виме очень просто, для того чтобы это работало динамически для c и c++ достаточно установить и сконфигурировать YouCompleteMe, после чего нам поможет must-have плагин syntastic, информацию о котором можно посмотреть на https://github.com/scrooloose/syntastic

![syntastic-demo](https://github.com/scrooloose/syntastic/raw/master/_assets/screenshot_1.png)

Теперь когда clang думает что в коде что-то написано неправильно сразу будет видно что и как. Впрочем в случае YouCompleteMe в случае когда в коде допущена ошибка его автокомплит и прочие фичи, по крайней мере большая их часть, работать не будут, пока она не будет исправлена. Что в общем-то довольно удобно.

Также существует довольно обширная поддержка для других языков, но как правило триггером там служит сохранение файла. Что в большинстве случаев не проблема.

Вот как он у меня настроен:

{% highlight vim %}
    let g:syntastic_error_symbol='✗'
    let g:syntastic_warning_symbol='⚠'
    let g:syntastic_style_error_symbol  = '⚡'
    let g:syntastic_style_warning_symbol  = '⚡'
    let g:syntastic_python_pylint_exe = "pylint2"
    let g:syntastic_mode_map = { 'mode': 'active',
        \ 'active_filetypes': [],
        \ 'passive_filetypes': ['python'] }

    let g:syntastic_cpp_compiler_options = ' -std=c++11'
    let g:syntastic_tex_checkers = ['lacheck']
    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_python_checkers = ['flake8']
    let g:syntastic_python_flake8_args = '--select=F,C9 --max-complexity=10'

    let g:syntastic_c_compiler_options = "-std=gnu11
        \  -Wall -Wextra -Wshadow -Wpointer-arith
        \  -Wcast-align -Wwrite-strings -Wmissing-prototypes
        \  -Wmissing-declarations -Wredundant-decls -Wnested-externs
        \  -Winline -Wno-long-long -Wuninitialized -Wconversion
        \  -Wstrict-prototypes -pedantic"
    let g:syntastic_stl_format = '[=> ln:%F (%t)]'
    let g:syntastic_aggregate_errors=1
    let g:syntastic_enable_signs=1
    let g:syntastic_auto_loc_list=2
    let g:syntastic_always_populate_loc_list=1
    let g:syntastic_c_no_include_search = 1
    let g:syntastic_c_auto_refresh_includes = 1
    let g:syntastic_c_check_header = 1
{% endhighlight %}

#### Сборка и компиляциия

Все мы привыкли к тому же в IDE всегда есть возможность удобной компиляции проектов по нажатию хоткея. В vim'е это тоже есть по умолчанию с помощью команды *:make*, но это не слишком-то удобно из-за синхнонного механизма работы. Впрочем мы можем воспользоваться замечательным плагином от tpope vim-dispatch(https://github.com/tpope/vim-dispatch). Он позволяет, помимо прочего выполнять компиляцию проекта в background'е с помощью *:Make*, а также запускать исполняемый файл в проекте(ну или точнее любой интерактивный процесс) через *:Start*

Лично мне больше всего по душе вот такие сочетания клавиш:
{% highlight vim %}
nmap MK :Make 
nmap MC :Make clean<cr>
{% endhighlight %}
Вроде ни с чем важным не конфликтуют и нет необходимости тянуться до функциональных клавиш(которых может и не быть).

В случае если появятся какие-то ошибки они будут показаны в quickfix.
Как это работает показано чуть ниже.

#### Быстрый поиск нужного файла в проекте(и не только)

Есть такая замечательная вещь как fzf, представляет из себя быстрый поисковик по файлам с fuzzy-finding'ом, написанный на ruby. Причем на активацию можно вешать абсолютно любые действия. В том числе и интегрировать его с vim(и tmux). Вот как это выглядит у меня, сначала компиляция с помощью vim+dispatch, потом поиск с помощью fzf:

![dispatch-fzf-demo](http://i.imgur.com/YGTKr5G.gif)

Если кто-то подскажет как делать более толквые гифки буду благодарен.

#### Работа с vcs

В практически любом современном программном проекте используется та или иная система контроля версий. В частности для git существует очень удобный плагин fugitive, который позволяет работать с git'ом не выходя из вима. На его официальной страничке https://github.com/tpope/vim-fugitive на гитхабе есть сборник скринкастов, так что подробно останавливаться на этом я смысла не вижу. Если совсем кратко, то большая часть команд начинается с *G* вместо аналогичной *<kbd>git [space]</kbd>*, например *git blame -> Gblame* и так далее. Работа с git как приложением выполняется через *:Git [гитовая команда]*. Плагин любим и мной и сообществом и на него стоит обратить внимание. Также для него есть ряд расширений. В частности я очень люблю использовать *Agit* ( https://github.com/cohama/agit.vim ), представляет собой некоторое подобие популярной утилиты *tig* (https://github.com/jonas/tig), которая представляет собой ncurses-based клиент для вима. С ней тоже очень удобно просматривать последние коммиты. Вот как выглядит выхлоп Agit:

![agit-demo](http://i.imgur.com/4oxxgBA.png)

Это первая из статей, которая посвящена vim'у, в следующей я расскажу об syntax highlighting и других украшательствах.

